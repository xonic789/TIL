## ThreadLocal
- 싱글턴(JVM에 오직 하나인 인스턴스) 빈에서 공유변수 (멤버변수) 를 사용하게 되면, 동시성 문제가 있다.
- 이는 읽기만 한다면 상관이 없으나, 수정시 문제가 된다.
- 왜냐하면 여러 쓰레드가 동시에 접근하여 수정하게 되면, 다른 쓰레드가 덮어쓰거나 할 수 있다
- 이 문제를 해결하려면, ThreadLocal을 사용하면 된다.
- ThreadLocal은 java에서 제공해주는 `java.lang.ThreadLocal`이다.
- 각 쓰레드마다 저장 공간을 달리해서 할당하기 때문에 동시성 문제에서 안전하다.
- 하지만 여기도 문제가 있는데, 쓰레드가 종료될 때 ThreadLocal에 담긴 변수를 지워줘야 한다.
- 이유가 뭘까?

### ThreadLocal - 주의사항
- ThreadLocal을 사용 후 지우지 않으면 WAS 같은 ThreadPool을 사용할 때 문제가 생긴다.
- ThreadPool은 처음 WAS 가 실행될 때 Thread를 미리 생성해놓는데, 요청시마다 ThreadPool에 Thread를 꺼내서 요청에 사용하게 한다.
- 그리고 요청이 종료되면, ThreadPool에 해당 요청에 사용된 Thread를 반납한다.
- 그래서 ThreadLocal에 저장되어 삭제되지 않은 값들이 재사용된 Thread에서 사용될 수 있다.
- **꼭 제거해야한다!!!!!!!!!!**

## 템플릿 메서드 패턴
#### 변하는 것과 변하지 않는 것을 분리
- 좋은 설계는 변하는 것과 변하지 않는 것을 분리하는 것이다.
- 여기서 핵심 기능 부분은 변하고, 로그 추적기를 사용하는 부분은 변하지 않는 부분이다.
- 이 둘을 분리해서 모듈화 해야한다.

### 템플릿 메서드 - 정의
- GOF 디자인 패턴에서는 템플릿 메서드 패턴을 다음과 같이 정의했다.<br> 
> 템플릿 메서드 디자인 패턴의 목적은 다음과 같다.<br>
> "작업에서 알고리즘의 골격을 정의하고 일부 단계를 하위 클래스로 연기합니다. 템플릿 메서드를 사용하면 하위 클래스가 알고리즘의<br>
> 구조를 변경하지 않고도 알고리즘의 특정 단계를 재정의할 수 있다." [GOF]

#### 풀어서 설명하면..
- 부모 클래스에 알고리즘의 골격인 템플릿을 정의하고, 일부 변경되는 로직은 자식 클래스에 정의하는 것이다.
- 이렇게 하면 자식 클래스가 알고리즘의 전체 구조를 변경하지 않고, 특정 부분만 재정의 할 수 있다. 결국 상속과 오버라이딩을 통한 다형성으로 문제를 해결하는 것이다.

#### "하지만"
- 템플릿 메서드 패턴은 상속을 사용한다. 따라서 상속에서 오는 단점들을 그대로 안고간다.
- 특히 자식 클래스가 부모 클래스와 컴파일 시점에 강하게 결합되는 문제가 있다.
- 이것은 의존 관계에 대한 문제이다.
- 자식 클래스 입장에서는 부모 클래스의 기능을 전혀 사용하지 않는다.<br>
<br>
- 상속을 받는다는 것은 특정 부모 클래스를 의존하고 있다는 것이다.
- 자식 클래스의 `extends` 다음에 바로 부모 클래스가 코드상에 지정되어 있다.
- 따라서 부모 클래스의 기능을 사용하든 사용하지 않든 간에 부모 클래스를 강하게 의존하게 된다.
- 여기서 강하게 의존한다는 뜻은 자식 클래스의 코드에 부모 클래스의 코드가 명확하게 적혀 있다는 뜻이다.
- UML에서 상속을 받으면, 삼각형 화살표가 `자식 -> 부모`를 향하고 있는 것은 이런 의존관계를 반영하는 것이다.
<br>
- 자식 클래스 입장에서는 부모 클래스의 기능을 전혀 사용하지 않는데도 불구하고 부모 클래스를 알아야한다.
- 이 것은 좋은 설계가 아니다. 그리고 이런 잘못된 의존관계 때문에 부모 클래스를 수정하면, 자식 클래스에도 영향을 줄 수 있다.
<br>
- 추가로 템플릿 메서드 패턴은 상속 구조를 사용하기 때문에, 별도의 클래스나 익명 내부 클래스를 만들어야 하는 부분도 복잡하다.
#### 템플릿 메서드 패턴과 비슷한 역할을 하면서, 상속의 단점을 제거할 수 있는 디자인 패턴이 바로 전략 패턴(Strategy Pattern)이다.

## 전략 패턴
### 전략 패턴 - 정의
- GOF 디자인 패턴에서 정의한 전략 패턴의 의도는 다음과 같다.
> 알고리즘 제품군을 정의하고 각각을 캡슐화하여 상호 교환 가능하게 만든다. 전략을 사용하면 알고리즘을 <br>
> 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있다.
#### 정리
- 변하지 않는 부분을 `Context`에 두고, 변하는 부분을 `Strategy`를 구현해서 만든다.
- 그리고 `Context`의 내부 필드에 `Strategy`를 주입해서 사용했다.

#### *선 조립 후 실행*
- 여기서, 중요한 부분은 `Context`의 내부 필드에 `Strategy`를 두고 사용하는 부분이다.
- 이 방식은 `Context`와 `Strategy`를 실행 전에 원하는 모양으로 **조립**해두고, 그 다음에 `Context`를 실행하는 선 조립, 후 실행 방식에서 매우 유용하다!!
- `Context`와 `Strategy`를 한 번 조립하고 나면 이후로는 `Context`를 실행하기만 하면 된다.
- 우리가 스프링으로 애플리케이션을 개발할 때 애플리케이션 로딩 시점에 의존관계 주입을 통해 필요한 의존관계를 모두 맺어두고 난 다음에 실제 요청을 처리하는 것과 같은 원리이다.
- 이 방식의 단점은 `Context`와 `Strategy`를 조립한 이후에는 전략을 변경하기가 번거롭다는 점이다.
- 물론 `Context`에 `Setter`를 제공해서 `Strategy`를 넘겨 받아 변경하면 되지만,
- `Context`를 싱글톤으로 사용할 때는 동시성 이슈 등 고려할 점이 많다.
- 그래서 전략을 실시간으로 변경해야 하면 차라리 `Context`를 하나 더 생성하고 그곳에 다른 `Strategy`를 주입하는 것이 더 나은 선택일 수 있다.
<br>
- 이렇게 먼저 조립하고 사용하는 방식보다 더 유연하게 전략 패턴을 사용하는 방법은 없을까?

#### 전략 패턴 파라미터
- Context에서 인스턴스 생성시, 즉 선 조립 후 실행하는 것에서
- Strategy를 파라미터로 받는다면, `Context.execute()` 메서드를 실행(클라이언트 입장에서 호출)할 때 Strategy를 구현해서 넘겨주면 된다.
- 즉 메서드 호출과 동시에 전략을 결정하는 것이다.

#### 정리
- 둘 다 장단점이 있다.
- 필드에 저장하는 방식
  - 선 조립, 후 실행 방법에 적합하다.
  - `Context`를 실행하는 시점에선 이미 조립이 끝났기 때문에, 전략을 신경쓰지 않고 단순히 실행만 하면 된다.
- 파라미터에 전달하는 방식
  - 실행할 때 마다 전략을 유연하게 변경할 수 있다.
  - 역시 단점이 존재하는데, 실행할 때마다 전략을 계속 지정해주어야 한다.

#### 템플릿
- 지금 우리가 해결하고 싶은 문제는 변하는 부분과 변하지 않는 부분을 분리하는 것이다.
- 변하지 않는 부분을 템플릿이라고 하고, 그 템플릿 안에서 변하는 부분에 약간 다른 코드 조각을 넘겨서 실행하는 것이 목적이다.
- 따라서 현재 시점에서 고민하는 문제는 실행 시점에 유연하게 실행 코드 조각을 전달하는 `ContextV2`가 더 적합하다.
- (Context에서 실행 당시 파라미터로 전략(코드 조각)을 넘기는 방법)

## 템플릿 콜백 패턴
> 콜백 정의 <br>
> 프로그래밍에서 콜백(callback) 또는 콜 애프터 함수(call-after function)는 다른 코드의 인수로서<br>
> 넘겨주는 실행 가능한 코드를 말한다. 콜백을 넘겨받는 코드는 이 콜백을 필요에 따라 즉시 실행할 수도<br>
> 있고, 아니면 나중에 실행할 수도 있다(위키백과 참고)

<br>

쉽게 이야기해서 `callback`은 코드가 호출(`call`)은 되는데 코드를 넘겨준 곳의 뒤 (`back`)에서 실행된다는 뜻이다.<br>

- `ContextV2` 에제에서 콜백은 `Strategy`이다.
- 여기에서는 클라이언트에서 직접 `Strategy`를 실행하는 것이 아니라, 클라이언트가<br>
  `Context.execute(..)`를 실행할 때 `Strategy`를 넘겨주고, `ContextV2` 뒤에서 `Strategy`가 실행된다.

#### *자바 언어에서 콜백*
- 자바 언어에서 실행 가능한 코드를 인수로 넘기려면 객체가 필요하다. 자바8부터는 람다를 사용할 수 있다.
- 자바 8 이전에는 보통 하나의 메소드를 가진 인터페이스를 구현하고, 주로 익명 내부 클래스를 사용했다.
#### 템플릿 콜백 패턴
- 스프링에서는 `ContextV2`와 같은 방식의 전략 패턴을 템플릿 콜백 패턴이라 한다.<br>
  전략 패턴에서 `Context`가 템플릿 역할을 하고, `Strategy` 부분이 콜백으로 넘어온다 생각하면 된다.
- 참고로 템플릿 콜백 패턴은 GOF 패턴은 아니고, 스프링 내부에서 이런 방식을 자주 사용하기 때문에<br>
  스프링 안에서만 이렇게 부른다. 전략 패턴에서 템플릿과 콜백 부분이 강조된 패턴이라 생각하면 된다.
- 스프링에서는 `JdbcTemplate`, `RestTemplate`, `TransactionTemplate`, `RedisTemplate`처럼<br>
  다양한 탬플릿 콜백 패턴이 사용된다. 스프링에서 이름이 `XxxTemplate`가 있다면 템플릿 콜백 패턴으로 만들어져 있다고 생각하면 된다.


  