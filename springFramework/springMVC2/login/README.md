**참고**<br>
**도메인이 가장 중요하다**.<br>
도메인 = 화면, UI, 기술 인프라 등등의 영역은 제외한 시스템이 구현해야 하는 핵심 비즈니스 업무 영역을
말함<br>
향후 web을 다른 기술로 바꾸어도 도메인은 그대로 유지할 수 있어야 한다.<br>
이렇게 하려면 web은 domain을 알고있지만 domain은 web을 모르도록 설계해야 한다. 이것을 web은 <br>
domain을 의존하지만, domain은 web을 의존하지 않는다고 표현한다. 예를 들어 web 패키지를 모두 <br>
삭제해도 domain에는 전혀 영향이 없도록 의존관계를 설계하는 것이 중요하다. 반대로 이야기하면 <br>
domain은 web을 참조하면 안된다.<br>

### 쿠키 사용해서 로그인 처리
1. 로그인 요청시 HttpServletResponse 를 이용하여 addCookie 해준다.
2. 이렇게 되면 응답시 set-cookie라는 헤더가 응답 헤더에 실린다.
3. 그 헤더를 보고 브라우저는 브라우저 쿠키 저장소에 저장한다.
4. 브라우저는 매 요청시 요청 헤더에 쿠키를 실어 보내준다.
5. 헌데, 이렇게 하면 정말 심각한 보안 문제가 있다.

### 쿠키와 보안 문제

**보안 문제**<br>
- 쿠키 값은 임의로 변경할 수 있다.
  - 클라이언트가 쿠키를 강제로 변경하면 다른 사용자가 된다.
- 쿠키에 보관된 정보는 훔쳐갈 수 있다.
  - 만약 쿠키에 개인정보나, 신용카드 정보가 있다면?
  - 이 정보가 웹 브라우저에도 보관되고, 네트워크 요청마다 계속 클라이언트에서 서버로 전달된다.
  - 쿠키의 정보가 나의 로컬 PC가 털릴 수도 있고, 네트워크 전송 구간에서 털릴 수도 있다. 
- 해커가 쿠키를 한번 훔쳐가면 평생 사용할 수 있다.
  - 해커가 쿠키를 훔쳐가서 그 쿠키로 악의적인 요청을 계속 시도할 수 있다.<br>
  
**대안**<br>
- 쿠키에 중요한 값을 노출하지 않고, 사용자 별로 예측 불가능한 임의의 토큰(랜덤 값)을 노출하고, 서버에서<br>
  토큰과 사용자 id를 매핑해서 인식한다. 그리고 서버에서 토큰을 관리한다.
- 토큰은 해커가 임의의 값을 넣어도 찾을 수 없도록 예상 불가능 해야 한다.<br>
  해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서 해당 토큰의 만료시간을 짧게(예: 30분)<br>
  유지한다. 또는 해킹이 의심되는 경우 서버에서 해당 토큰을 강제로 제거하면 된다.<br>

### 로그인 처리하기 - 세션 동작 방식
1. ID와 비밀번호를 가지고 서버에 요청한다.
2. 서버에서는 DB를 뒤져서 일치하는지 확인한다.
3. 일치 할 시 로그인 처리를 하고, 서버에서는 UUID 같은 범용 고유 식별자를 가지고 쿠키에 전송해준다.
4. 그 UUID는 서버에서 세션 저장소에 저장을 하고, 다음 요청부터는 그 쿠키 정보를 가지고 회원 정보를 들고 오면 된다.

#### "정리"
- 쿠키 값을 변조 가능 => 예상 불가능한 복잡한 세션 id를 사용한다.
- 쿠키에 보관하는 정보는 클라이언트 해킹시 털릴 가능성이 있다. => 세션 id가 털려도 여기에는 중요한 정보가 없다.
- 쿠키 탈취 후 사용 => 해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서 만료 시간을 짧게 (예를 들어 30분) 또는<br>
  해킹이 의심되는 경우 서버에서 해당 세션을 강제로 제거하면 된다.
 
### 세션
- 세션이 다를게 없고, 자바에서 제공하는 인터페이스이다.
- 구현체는 서블릿이다. (아파치)
- 세션 저장소를 메모리에 올리고,(해쉬 테이블 구조) key 값을 생성해서 value로 로그인 한 사용자에게 필요한 값을 저장한다.
- 그리고 그 key 값을 응답에 Set-cookie하면 브라우저가 그 key 값을 매 요청마다 보내줄 것이다.
- 서버에서는 HttpServletRequest 인스턴스에서 session을 꺼낼 수 있고, 
- key값을 넣으면 value가 튀어나올 것이다.

### 로그인 처리하기 - 서블릿 세션
- 스프링은 세션을 더 편리하게 사용할 수 있도록 `@SessionAttribute`를 지원한다.
- 이미 로그인 된 사용자를 찾을 때는 다음과 같이 사용하면 된다. 참고로 이 기능은 세션을 생성하지 않는다.
- `@SessionAttribute(name = "loginMember", required = false) Member loginMember`

### 세션 정보와 타임아웃 설정

#### 세션 타임아웃 설정
- 세션은 사용자가 로그아웃을 직접 호출해서 (`session.invalidate()`)가 호출 되는 경우에 삭제된다.
- 그런데 대부분의 사용자는 로그아웃을 선택하지 않고, 그냥 웹 브라우저를 종료한다.
- 문제는 HTTP가 비연결성(ConnectionLess)이므로 서버 입장에서는 해당 사용자가 웹 브라우저를 종료한 것인지 아닌지를 인식할 수 없다.
- 따라서 서버에서 세션 데이터를 언제 삭제해야 하는지 판단하기가 어렵다.<br>

이 경우 남아 있는 세션을 무한정 보관하면 다음과 같은 문제가 발생할 수 있다.
- 세션과 관련된 쿠키(JESSIONID)를 탈취 당했을 경우 오랜 시간이 지나도 해당 쿠키로 악의적인 요청을 할 수 있다.
- 세션은 기본적을 메모리에 생성된다. 메모리의 크기가 무한하지 않기 때문에 오랜 시간이 지나도 해당 쿠키로 악의적인 요청을 할 수 있다.

#### 세션 타임아웃 설정
스프링 부트로 글로벌 설정 <br>
`application.properties`<br>
`server.servlet.session.timeout=60`: 60초, 기본은 1800(30분)<br>
(글로벌 설정은 분 단위로 설정해야한다 !)<br>

특정 세션 단위로 시간 설정
```properties
session.setMaxInactiveInterval(1000); //1000초
```

#### 세션 타임아웃 발생
세션의 타임아웃 시간은 해당 세션과 관련된 JESSIONID를 전달하는 HTTP 요청이 있으면 현재 시간으로 다시 초기화 된다.<br>
이렇게 초기화 되면 세션 타임아웃으로 설정한 시간동안 세션을 추가로 사용할 수 있다.<br>
`LastAccessedTime`이후로 timeout 시간이 지나면, WAS가 내부에서 해당 세션을 제거한다.

## 로그인 처리 - 필터, 인터셉터

### 서블릿 필터 - 소개

#### 공통 관심사항
- 모든 인증이 필요한 페이지에 인증 로직을 추가해야한다.
- 모든 컨트롤러 로직에 공통으로 로그인 여부를 확인해야한다.
- 더 큰 문제는 향후 로그인과 관련된 로직이 변경될 때 마다 작성한 모든 로직을 다 수정해야 할 수 있다.
- 이러한 공통 관심사는 스프링의 AOP로도 해결할 수 있지만, 웹과 관련된 공통 관심사는 서블릿 필터 또는 스프링 인터셉터를 사용하는 것이 좋다.
- 웹과 관련된 공통 관심사를 처리할 때는 HTTP의 헤더나 URL의 정보들이 필요한데, 서블릿 필터나 스프링 인터셉터에는 `HttpServletRequest`를 제공한다.

### 서플릿 필터 소개
- 필터는 서블릿이 지원하는 수문장이다. 필터의 특성은 다음과 같다

#### 필터 흐름
```text
HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 컨트롤러
```
필터를 적용하면 필터가 호출 된 다음에 서블릿이 호출된다. 참고로 필터는 특정 URL 패턴에 적용할 수 있다.<br>
`/*`이라고 하면 모든 요청에 필터가 적용된다. 참고로 스프링을 사용하는 경우 여기서 말하는 서블릿은 스프링의 디스패처 서블릿으로 생각하면 된다.

#### 필터 제한
```text
HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 컨트롤러 //로그인 사용자
HTTP 요청 -> WAS -> 필터(적절하지 않은 요청이라 판단, 서블릿 호출X) //비 로그인 사용자
```
필터에서 적절하지 않은 요청이라고 판단하면 거기서 끝을 낼 수있다. 그래서 로그인 여부를 체크하기에 딱 좋다.

#### 필터 체인
```text
HTTP 요청 -> WAS -> 필터1 -> 필터2 -> 필터3 -> 서블릿 -> 컨트롤러
```
필터는 체인으로 구성되는데, 중간에 필터를 자유롭게 추가할 수 있다. 예를 들어서 로그를 남기는 필터를 먼저 적용하고,<br>
그 다음에 로그인 여부를 체크하는 필터를 만들 수 있다.

### 필터 인터페이스
```java
public interface Filter {
 public default void init(FilterConfig filterConfig) throws ServletException
{}
 public void doFilter(ServletRequest request, ServletResponse response,
 FilterChain chain) throws IOException, ServletException;
 public default void destroy() {}
}
```
필터 인터페이스를 구현하고 등록하면 서블릿 컨테이너가 필터를 싱글톤 객체로 생성하고, 관리한다.
- `init()`: 필터 초기화 메서드, 서블릿 컨테이너가 생성될 때 호출된다.
- `doFilter()`: 고객의 요청이 올 때 마다 해당 메서드가 호출된다. 필터의 로직을 구현하면 된다.
- `destroy()`: 필터 종료 메서드, 서블릿 컨테이너가 종료될 때 호출된다.

### 스프링 인터셉터
- 스프링 인터셉터도 서블릿 필터와 같이 웹과 관련된 공통 관심 사항을 효과적으로 해결할 수 있는 기술이다.
  서블릿 필터가 서블릿이 제공하는 기술이라면, 스프링 인터셉터는 스프링 MVC가 제공하는 기술이다

#### 스프링 인터셉터 흐름
```text
HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터 -> 컨트롤러
```
- 스프링 인터셉터는 디스패처 서블릿과 컨트롤러 사이에서 컨트롤러 호출 직전에 호출된다.
- 스프링 인터셉터는 스프링 MVC가 제공하는 기능이기 때문에 결국 디스패처 서블릿 이후에 등장하게 된다.<br>
  스프링 MVC의 시작점이 디스패처 서블릿이라고 생각해보면 이해가 된다.
- 스프링 인터셉터에도 URL 패턴을 적용할 수 있는데, 서블릿 URL 패턴과는 다르고, 매우 정밀하게 설정할 수 있다.

#### 스프링 인터셉터 제한
```text
HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터 -> 컨트롤러 //로그인 사용자
HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터(적절하지 않은 요청이라 판단, 컨트롤러 호출
X) // 비 로그인 사용자
```
인터셉터에서 적절하지 않은 요청이라고 판단하면 거기에서 끝을 낼 수도 있기 때문에 로그인 여부를 체크하기에 딱 좋다.
#### 스프링 인터셉터 체인
```text
HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 인터셉터1 -> 인터셉터2 -> 컨트롤러
```
스프링 인터셉터는 체인으로 구성되는데, 중간에 인터셉터를 자유롭게 추가할 수 있다.

#### 스프링 인터셉터 인터페이스
- 스프링의 인터셉터를 사용하려면 `HandlerInterceptor` 인터페이스를 구현하면 된다.
- 서블릿 필터의 경우 단순하게 `doFilter()` 하나만 제공된다. 인터셉터는 컨트롤러 호출 전( `preHandle` ),
  호출 후( `postHandle` ), 요청 완료 이후( `afterCompletion` )와 같이 단계적으로 잘 세분화 되어 있다
- 서블릿 필터의 경우 단순히 `request` , `response` 만 제공했지만, 인터셉터는 어떤 컨트롤러( `handler` )가
  호출되는지 호출 정보도 받을 수 있다. 그리고 어떤 `modelAndView` 가 반환되는지 응답 정보도 받을 수
  있다.

#### 스프링 인터셉터 호출 흐름
<img width="642" alt="image" src="https://user-images.githubusercontent.com/64122884/161432650-f67ac4e0-95cd-46a8-a400-ba51c7898d3d.png"/>

#### 정상 흐름
- `preHandle` : 컨트롤러 호출 전에 호출된다. (더 정확히는 핸들러 어댑터 호출 전에 호출된다.)
  - `preHandle` 의 응답값이 `true` 이면 다음으로 진행하고, `false` 이면 더는 진행하지 않는다. `false`
  인 경우 나머지 인터셉터는 물론이고, 핸들러 어댑터도 호출되지 않는다. 그림에서 1번에서 끝이
  나버린다.
- `postHandle` : 컨트롤러 호출 후에 호출된다. (더 정확히는 핸들러 어댑터 호출 후에 호출된다.)
- `afterCompletion` : 뷰가 렌더링 된 이후에 호출된다

#### 스프링 인터셉터 예외 상황

#### 예외가 발생시 인터셉터 메서드 호출에 관하여
- `preHandle`: 컨트롤러 호출 전에 호출된다.
- `postHandle`: 컨트롤러에서 예외가 발생하면 `postHandle`은 호출되지 않는다.
- `afterCompletion`: `afterCompletion`은 항상 호출된다. 이 경우 예외(`ex`)를 파라미터로 받아서 어떤 예외가 발생했는지 로그로 출력할 수 있다.

#### afterCompletion은 예외가 발생되도 호출된다.
- 예외가 발생하면 `postHandle()`는 호출되지 않으므로 예외와 무관하게 공통 처리를 하려면 `afterCompletion()`을 사용해야 한다.
- 예외가 발생하면 `afterCompletion()`에 예외 정보(`ex`)를 포함해서 호출된다.

#### 정리
인터셉터는 스프링 MVC 구조에 특화된 필터 기능을 제공한다고 이해하면 된다. 스프링 MVC를 사용하고,<br>
특별히 필터를 꼭 사용해야 하는 상황이 아니라면 인터셉터를 사용하는 것이 더 편리하다.

### 스프링 인터셉터 - 로그
